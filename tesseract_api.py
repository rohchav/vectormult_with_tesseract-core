# Copyright 2025 Pasteur Labs. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

# Tesseract API module for vectormult
# Generated by tesseract 0.8.5 on 2025-04-30T13:13:36.916609

import numpy as np
from pydantic import BaseModel, Field, model_validator

from tesseract_core.runtime import Array, Differentiable, Float32, Float64


class InputSchema(BaseModel):
    a: Differentiable[Array[(None,), Float32]] = Field(
        description="An arbitrary vector."
    )
    b: Differentiable[Array[(None,), Float32]] = Field(
        description="An arbitrary vector. Needs to have the same dimensions as a."
    )

    @model_validator(mode="after")
    def validate_dimensions(self):
        if self.a.shape != self.b.shape:
            raise ValueError("Vectors a and b must have the same dimensions.")
        return self
    
class OutputSchema(BaseModel):
    result: Differentiable[Array[(None,), Float32]] = Field(
        description="The element-wise product of vectors a and b."
    )

def apply(inputs: InputSchema) -> OutputSchema:
    """
    Apply the vectormult operation to the input vectors a and b.

    Args:
        inputs (InputSchema): The input schema containing vectors a and b.

    Returns:
        OutputSchema: The output schema containing the result of the element-wise product.
    """
    a = inputs.a
    b = inputs.b
    result = a * b  # Element-wise multiplication
    return OutputSchema(result=result)

def apply_with_numpy(inputs: InputSchema) -> OutputSchema:
    """
    Apply the vectormult operation using NumPy for element-wise multiplication.

    Args:
        inputs (InputSchema): The input schema containing vectors a and b.

    Returns:
        OutputSchema: The output schema containing the result of the element-wise product.
    """
    a = np.array(inputs.a)
    b = np.array(inputs.b)
    result = a * b  # Element-wise multiplication
    return OutputSchema(result=result)

def apply_with_numpy_float64(inputs: InputSchema) -> OutputSchema:
    """
    Apply the vectormult operation using NumPy with Float64 precision.

    Args:
        inputs (InputSchema): The input schema containing vectors a and b.

    Returns:
        OutputSchema: The output schema containing the result of the element-wise product.
    """
    a = np.array(inputs.a, dtype=np.float64)
    b = np.array(inputs.b, dtype=np.float64)
    result = a * b  # Element-wise multiplication
    return OutputSchema(result=result)

def apply_with_numpy_float32(inputs: InputSchema) -> OutputSchema:
    """
    Apply the vectormult operation using NumPy with Float32 precision.

    Args:
        inputs (InputSchema): The input schema containing vectors a and b.

    Returns:
        OutputSchema: The output schema containing the result of the element-wise product.
    """
    a = np.array(inputs.a, dtype=np.float32)
    b = np.array(inputs.b, dtype=np.float32)
    result = a * b  # Element-wise multiplication
    return OutputSchema(result=result)

# def jacobian(inputs: InputSchema) -> OutputSchema:
#     """
#     Compute the Jacobian of the vectormult operation.

#     Args:
#         inputs (InputSchema): The input schema containing vectors a and b.

#     Returns:
#         OutputSchema: The output schema containing the Jacobian of the operation.
#     """
#     # The Jacobian of element-wise multiplication is a diagonal matrix
#     # where each diagonal element is the corresponding element of the other vector.
#     inputs: InputSchema,
#     jac_inputs = set[str],
#     jac_outputs = set[str],

#     assert jac_outputs =={"result"}
#     n = len(inputs.a)

#     partials = {}
#     partials["a"] = np.eye(n) 
#     partials["b"] = np.eye(n)

#     jacobian = {"result": {v: partials[v] for v in jac_inputs}}

#     return jacobian